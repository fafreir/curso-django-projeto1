- Instalar o ambiente virtual
python -m venv venv (Windows)
python3 -m venv venv (Linux)

- Ativar o ambiente virtual
.\venv\Scripts\activate.bat  (Windows)
source venv\bin\activate (Linux)

- Para desativar o ambiente virtual
deactivate
------------------------------------------

- Verificar os pacotes instalados
pip freeze

- Gerar o relatório dos pacotes
pip freeze > requirements.txt 

- Instalar o requirements
pip install -r requirements.txt

-----------------------------------

- Atualize o setuptools e o wheel
python -m pip install pip setuptools wheel --upgrade

-----------------------------------

- Habilite o ambiente virtual
- Instale o Django
pip install django

- Saber a versão do django
django-admin --version

- Saber os comandos
django-admin --help

- Criando o projeto inicial
django-admin startproject projeto .

- Executar o servidor
python manage.py runserver

- Migração 
python manage.py migrate
-----------------------------------

Configurar o git

git config --global user.name "Fabrício Adriel Coelho Freire"
git config --global user.email "fabricioadriel@yahoo.com.br"
git config --global init.defaultBranch main
git init
- Se quiser apagar a pasta do git
rm -Rf .git

- Gerar uma chave ssh
ssh -keygen

git remote add origin link
git remote add origin https://github.com/fafreir/curso-django-projeto1.git
git push --set-upstream origin main
git push -u origin fafreir

- Alguns comandos
git status
git add .
git commit -m "Mensagem"
git push

Link: https://github.com/luizomf/curso-django-projeto1

-----------------------------------

django-admin x manage
- A diferença que o manage.py, busca dos settings. Porém os comandos são os mesmos.
- O manage.py configura a variavel de ambiente DJANGO_SETTINGS_MODULE apontando para o arquivo settings.py do seu projeto Django.
-----------------------------------
URL
- é onde será configurado a rota

VIEW
- A URL irá buscar na view, e nessa função terá o argumento o request
- No caso o cliente, faz a request
- irá retornar uma HttpResponse
- Que o servidor responde

LINKS:
Codigo Status: https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Status
Metodos Requisição: https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Methods

---------------------------------
CRIANDO APP
python manage.py startapp recipes

---------------------------------

---------------------------------
INCLUDE
include - é herdar ou incluir a url 

from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls), # dominio.com/
    path('', include('recipes.urls')), # dominio.com/
    path('recipes', include('recipes.urls')), # dominio.com/recipes/
]
---------------------------------

---------------------------------
RENDER - irá renderizar uma pagina html, vai buscar na pasta templates.

from django.shortcuts import render

def home(request):
    return render(request, 'home.html')

---------------------------------

TEMPLATE DOES NOT EXIST

- Necessário atualizar no projeto, o arquivo settings.
- Inserir o app em INSTALLED_APPS, o nome do app

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'recipes',
]


INSERIR O TEMPLATE EM TEMPLATE, EM SETTINGS
- Irá seguir a ordem do Template
- Template, em dirs
- BASEDIR, é referente a raiz

TEMPLATES = [
    {
	'DIRS': [
            BASE_DIR / 'base_templates',
        ],
    }

---------------------------------

NAMESPACE 
- Quando possuem arquivos com o mesmo nome, pode dar conflito
- Para corrigir isso, em templates coloca o nome do app.
- nome_app/arquivo ou global/arquivo

def home(request):
    return render(request, 'recipes/home.html')
---------------------------------

PRINTAR

{{  }} é o mesmo que um print
<h1>Recipes {{ name }} </h1>

-----------------------------------

EXECUTAR COMANDO

{% include 'caminho/nome.extensão'%}

{% include 'recipes/partials/recipe.html' %}
-----------------------------------

ARQUIVOS ESTATICOS
- Documentação: https://docs.djangoproject.com/pt-br/3.2/howto/static-files/
- No settings, precisa ter no "INSTALLED_APPS", o "'django.contrib.staticfiles'"
- Ainda em settings, STATIC_URL = 'static/'
- Se alterar o STATIC_URL, vai aparecer com o nome alterado no caminho ao procurar no html
- Por padrão, vai buscar na pasta 'static'

NO ARQUIVO QUE VOU CARREGAR, NO TOPO INSIRO
{% load static %}

ONDE INSERIR O CSS
- Utilizo {% static 'caminho/nome.extensao' %}
<link rel="stylesheet" href="{% static 'recipes/css/styles.css' %}">

INSERIR CSS, SEM SER APP
- No settings, inserir o STATICFILES_DIRS

STATICFILES_DIRS = [
    BASE_DIR / 'base_static',
]

JUNTAR TODOS OS CSS
- Configurar no settings
STATIC_ROOT = BASE_DIR/'static'

- Rodar o comando
python manage.py collectstatic
==================================================

URL
- Documentação: https://docs.djangoproject.com/pt-br/3.2/topics/http/urls/
- Path converters: int, str, slug, uuid
- Podemos utilizar para forçar <path_converter:id>

urlpatterns = [
    path('', views.home),
    path('recipes/<int:id>/', views.recipe),
]

==================================================

DEMARCAR CONTEUDO
- Utilizo o block, porém antes é necessário utilizar o extends
{% block nome_conteudo %} {% endblock nome_opcional %}

ONDE UTILIZAR O CONTEUDO DEMARCADO
- Utiliza o extends, para herdar e depois demarco o bloco
{% extends 'global/base.html' %}

==================================================

TAGS
- Documentação: https://docs.djangoproject.com/pt-br/3.2/topics/templates/
                https://docs.djangoproject.com/pt-br/3.2/ref/templates/language/
- Documentação: https://docs.djangoproject.com/pt-br/3.2/ref/templates/builtins/#ref-templates-builtins-tags

==================================================

NAME
name = para formar url dinamicamente, será para nome unico, será inserido em urls, do aplicativo.

Temos 2 maneiras: Sem o app_name e Com o app_name

NAME - SEM O APPNAME
Observação: Utilizar dessa maneira, se não utilizar appname

urlpatterns = [
    path('', views.home, name = "recipes-home"),
    path('recipes/<int:id>/', views.recipe, name="recipes-recipe"),
]

Depois onde vou utilizar utilizar {% url 'name' %}
<a class="main-logo" href="{% url 'recipes-home' %}">

NAME - COM APPNAME
- Em urls, do aplicativo, cria a variavel app_name
app_name = 'recipes'

Depois onde vou utilizar utilizar {% url 'appname:name' %}
<a href="{% url 'recipes:recipe'  recipe.id %}">

==================================================

MODELS

- Criar a classe com o nome da tabela, herdar models.Model
class Category(models.Model):

CHAVE ESTRANGEIRA 
- models.ForeinKey
- on_delete=models.SET_NULL, null=True
- on_delete=models.SET_NULL -> Se APAGAR o campo category, em Recipe, o que foi criado nesse campo ficará NULO
- null=True -> O campo pode ser NULO

category = models.ForeignKey(
        Category, on_delete=models.SET_NULL, null=True)

- Para gerar as migrações
python manage.py migrate 

- Para aplicar/migrar ou gerar os arquivos das migrações
python manage.py makemigrations

DOCUMENTAÇÃO (MODEL FIELD): https://docs.djangoproject.com/pt-br/3.2/ref/models/fields/

auto_now -> atualiza a data toda vez que o objeto é modificado
auto_now_add -> atualiza a data apenas na criação do objeto

================================

CRIAR USUARIO ADMIN
python manage.py createsuperuser

APARECER OS MODELOS NO ADMIN
- Acessar na aplicação/app o arquivo admin.py
- importar o models
- Criar uma classe, herdar admin.ModelAdmin
- registrar modelo admin(modelo, classe)

from django.contrib import admin
from .models import Category

class CategoryAdmin(admin.ModelAdmin):
    ...


admin.site.register(Category, CategoryAdmin)

TEMOS 2 MANEIRAS DE REGISTRAR
1) admin.site.register(model, classeadmin) 
2) @admin.register(model)

- Se o migrate não funcionar, apresentar erro "no such table":
- https://stackoverflow.com/questions/25771755/django-operationalerror-no-such-table
python manage.py migrate --run-syncdb

---------------------------------
PARA IMAGENS NO BANCO DE DADOS
- Iremos informar um local 
- Vamos no settings.py do projeto e adicione

MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / 'media'

PROBLEMAS PARA VISUALIZAR IMAGENS
- Para isso é necessário configurar a URL do projeto
- Comece importando static e settings
- No static, vamos configurar o arquivo estatico
- No settings na url, toda vez que for ter que algo do settings 
- Não é recomendado acessar diretamente o settings

from django.conf.urls.static import static
from django.conf import settings

- concatenar a urlpatterns, com o static, buscandos dos settings o MEDIA_URL, e o document root, os settings de MEDIA_ROOT
urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

- Faça o mesmo com os arquivos estaticos
urlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)

SE QUISER DEIXAR UMA CAIXINHA PARA LIMPAR A IMAGEM
- Vai precisar alterar no banco
- blank = True, default =''
- blank = True -> não valida o formulário
cover = models.ImageField(
        upload_to='recipes/covers/%Y/%m/%d/', blank=True, default='')

- Necessário realizar um if, para apresentar erro ao abrir a imagem.
    {% if recipe.cover %}
        <div class="recipe-cover">
            <a href="{% url 'recipes:recipe'  recipe.id %}">
                <img src="{{ recipe.cover.url }}" alt="Temporário">
            </a>
        </div>
    {% endif %}

FOREIGN KEY COM BLANK
- Se excluir o valor ficará nulo
- Porém se for atualizar qualquer campo, informará que é obrigatório o campo da Foreign Key é obrigatória
- Para corrigir isso 
- blank=True, default=None
category = models.ForeignKey(
        Category, on_delete=models.SET_NULL, null=True, blank=True, default=None)
---------------------------------

SHELL

Documentação: https://docs.djangoproject.com/pt-br/3.2/ref/models/querysets/

- Comando para acessar shell
python manage.py shell

- Importar o models
from recipes.models import Recipe, Category

- Retornar todos as categorias
categories = Category.objects.all()

- Visualizar as QuerySet, que é um iteravel
categories

- Posso ordenar pelo id
categories.order_by('id')

- Posso ordenar pelo id decrescente
categories.order_by("-id")

- Posso ordenar pelo name
categories.order_by('name')

- Posso utilizar mais de um campo para ordenação
categories.order_by('id','-name')

- Retornar todos as receitas
recipes = Recipe.objects.all()

- Posso realizar um for
for recipe in recipes: print(recipe.id, recipe.title)

- Posso realizar um for, pelo id decrescente
for recipe in recipes.order_by('-id'): print(recipe.id, recipe.title)

- Retornar somente o primeiro, porém dessa forma não é mais um QuerySet
recipes.order_by('id').first()

- Verificar os campos
recipe = recipes.order_by('id').first()
recipe._meta.get_fields()

- Acessar pelo indice o primeiro campo
recipe._meta.get_fields()[0]

- Verificar o nome do campo desse indice
recipe._meta.get_fields()[0].name

- Acessar o valor, tem algumas maneiras
getattr(recipe, recipe._meta.get_fields()[0].name)
getattr(recipe, 'id')
recipe.id

- Criar uma nova categoria, modo lazy
- Porém só irá aparecer no Django quando salvar, devido ser lazy
new_category = Category()
new_category.name = 'nova categoria'
new_category.save()

- Saber qual id está 
new_category.id

- Criar uma nova categoria, não lazy
new_category = Category.objects.create()

new_category = Category.objects.create(name = 'Isso foi criado via objects.create')

- Posso alterar o objeto criado, modo lazy, precisa salvar para aparecer
new_category.name = "Fui atualizado"
new_category.save()

- Deletar
new_category.delete()

- Posso filtrar
categories = Category.objects.filter(id=5)

- Pegar apenas um, sem o iteravel ou queryset
categories = Category.objects.fiter(id=5).first()

- Utilizando o get, retorna o mesmo de acima
- Porém se o que filtro não existir, irá retornar um erro, enquanto filter irá retornar uma lista vazia
categories = Category.objects.get(id=5)

- Criar usuário
from django.contrib.auth.models import User
User.objects.create_user(first_name='Maria', last_name='Helena', username='mariahelena', email='maria@email.com', password='123')

- Realizar consultas
from recipes.models import Recipe
recipes = Recipe.objects.filter(category__id = 6, is_published = True,).order_by('id') 
# recipes = Recipe.objects.all().order_by('id') 

- Se tiver uma queryset, com várias receitas, poderia pegar a primeira
recipes.first()

- Pegar a ultima receita
recipes.last()

- Pegar a primeira, porém somente como String.
- Lembrando que Recipe, tem category, como FK e acessa o campo name, de Category
recipes.first().category.name

- Para sair do shell
quit()
---------------------------------

FILTER

FOREIGN KEY
No Django, consigo acessar campos da foreign key, para isso uso dois underlines __
- category é a foreign key de Recipe
- id é o campo que quero acessar de Category
recipes = Recipe.objects.filter(category__id=category_id).order_by('-id')

NO PROPRIO CAMPO
recipes = Recipe.objects.filter(is_published=True).order_by('-id')


---------------------------------

NA HOME, MOSTRAR USUÁRIO COMO DESCONHECIDO

- Alterar em recipe.html 
<div class="recipe-author">

        <span class="recipe-author-item">
            <i class="fas fa-user"></i>
            {% if recipe.author is not None %}
                {% if recipe.author.first_name%}
                    {{ recipe.author.first_name }} {{ recipe.author.last_name}}
                {% else %}
                    {{ recipe.author.username }}
                {% endif %}
            {% else %}
                Desconhecido
            {% endif %}
        </span>

---------------------------------

PEGAR PRIMEIRO RESULTADO DE UMA QUERY E TRANSFORMAR EM UMA STRING
recipes = Recipe.objects.all().order_by('id') 
recipes.first().category.name 

- Posso pegar dentro do template, inserir dentro de uma variavel 
- Utilizando o fstrings
'title': f'{recipes.first().category.name} - Category '

---------------------------------

NÃO LOCALIZAR A URL
- Temos algumas opções 
- O que quero acessar é 'title': f'{recipes.first().category.name} - Category '

1) Utilizar o getattr
- getattr(objeto, 'espero_localizar', 'caso não encontre')
category_name = getattr(
        getattr(recipes.first(), 'category', None), 'name', 'Not found')
'title': f'{category_name} - Category '

2) Utilizar o HttpResponse
